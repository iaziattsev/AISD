Bucket Sort (на русском: карманный, блочный или корзиночный) - алгоритм сортировки,
основывающийся на принципе закона равномерного распределения, где любое значение имеет
одинаковую вероятность. То есть X может принять одну из величин: X1, X2,.., Xn.
При этом каждая их вероятность будет равна 1/n.
Для Bucket Sort на вход обязательно идет массив, а также желательно
максимальное число.
Данный вид сортировки очень похож на PigeonHole Sort, так как обе
завязаны на работе с максимумом массива, чтобы получить некоторый отрезок,
также мы группируем числа.
Но при большой числовой области эффективнее использовать Bucket Sort.
PigeonHole не работает с целыми числами.

Описание алгоритма.
1. Настройте массив изначально пустых «ковшей».
2. Пройдитесь по исходному массиву, поместив каждый объект в свое ведро.
Наш вход: 1, 20, 11, 4, 30, 13. Максимальное - 30, количество - 6
Тогда этот массив рассортируется как:
{| 0 - 4 |} {| 5 - 9 |} {| 10 - 14 |} {| 15 - 19 |} {| 20 - 24 |} {| 25 - 29 |} {| 30 |}
    1, 4                    11, 13                        20                       30
Индекс массива "ведер" мы считаем так: кол-во элементов * некоторый элементв / макс-ое число.
Округляем данное выражение в меньшую сторону. Последний ведро будет иметь
индекс n (макс * кол-во / макс = кол-во) и единственный элемент - максимальное число. Поэтому
нужен массив размером n + 1.
3. Отсортируйте каждое непустое ведро.
4. Посетите корзины по порядку и поместите все элементы обратно в исходный массив.

Сложность алгоритма по времени.
Худший случай: Случай, когда входные данные распределены неравномерно,
то есть некоторые ведра содержат больше положенного количества, или вовсе
все элементы в одном ведре. Тогда общая производительность будет зависеть
от алгоритма, который сортирует каждое ведро. Если это сортировка вставками,
то это будет n в квадрате, если же слиянием - n*lon (n).
Средний случай: Данные распределены равномерно, нужно разделить по
карманам n входных величин. Поскольку входные числа равномерно распределены,
предполагается, что в каждый карман попадет небольшое количество чисел.
O(n) + E(i=0 to n)(O(n(i)^2)).
Лучший случай: в каждом ведре по одному элементу, тогда сама сортировка ведер
займет лишь константу. Нам лишь остается пройтись и собрать все элементы.
for each bucket b in bucket_list do
    for each element i in b do
        push i to array
Сложность: O(n+k).

Сложность алгоритма по памяти.
Так как мы имеем n + 1 ведер и n элементов, а также для упрощения построения нового массива
мы добавили новый лист массивов bucketArray с k элементами. Таким О(n + k). Без bucketArray сложность
будет O(n).